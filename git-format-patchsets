#!/bin/bash
set -e
set -u


scriptname="git format-patchset"

# help text
read -r -d '' cli_help <<EOD || :
Format multi-patches from commits.

Usage:
    ${scriptname} [OPTIONS] <revision-range>

Description:"
    Format multi-patches, i.e. patch files with multiple complete commits
    inside, from a given commit range. Commits can be assigned to/picked
    for patch-sets interactively (similar to git rebase), or via a

        Patchset: <name>

    tag in the commit message.

Options:
    -h, --help        Show this help message.
    -t, --from-tags   Look for 'Patchset:' tags in commit messages and
                      assign patch-set based on this. Commits without a
                      'Patchset:' tag will be formatted in their own file.
    -a, --no-confirm  Do not open editor for interactive assignment, i.e.
                      perform assignment automatically without user
                      interaction. Only valid with -t/--from-tags.
EOD


GIT_OPTS="${GIT_OPTS:-""}"

revs=""
git_dir="$(git rev-parse --show-toplevel)/.git"
editor=${EDITOR:-vim}

opt_help=n
opt_tags=n
opt_noconfirm=n


while (( "${#}" )); do
    case ${1} in
        -h|--help)
            opt_help=y
            shift
            ;;
        -t|--from-tags)
            opt_tags=y
            shift
            ;;
        -a|--no-confirm)
            opt_noconfirm=y
            shift
            ;;
        *)
            revs="${1}"
            shift
            ;;
    esac
done

# handle help
if [[ "${opt_help}" == y ]]; then
    echo "${cli_help}"
    exit 0
fi

# fix revision input
if [[ ! "${revs}" == *".."* ]]; then
    revs="${revs}.."
fi


# prepare instruction-file
echo "# Format patchsets in range ${revs}" > "${git_dir}/TMP_MULTIPATCH"

log=$(git log --reverse --oneline --no-merges "${revs}")

prev=""
if [[ "${opt_tags}" == y ]]; then

    while IFS= read -r entry; do
        read -r -a fields <<< "${entry}"

        commit="${fields[0]}"
        message=$(git log --format=%B "${commit}" -1)
        patchset=""

        while IFS= read -r line; do
            # split away right-hand-side comment
            IFS="#" read -r -a line <<< "${line}"

            if [[ "${#line[@]}" -eq 0 ]]
            then
                continue
            fi

            text="${line[0]}"

            # split line into tokens
            IFS=" " read -r -a tokens <<< "${text}"

            if [[ "${#tokens[@]}" -eq 0 ]]
            then
                continue
            fi

            # if tag, set patchset
            if [[ "${tokens[0]}" == "Patchset:" ]]; then
                patchset="${tokens[*]:1}"
            fi
        done <<< "${message}"

        if [ -z "${patchset}" ]; then
            patchset="${fields[*]:1}"
            patchset="${patchset//\:/}"
            patchset="${patchset//\(/}"
            patchset="${patchset//\)/}"
            patchset="${patchset//\//-}"
            patchset="${patchset// /-}"
            patchset=$(echo "${patchset}" | cut -c 1-52)
        fi

        if [[ "${prev}" != "${patchset}" ]]; then
            echo "" >> "${git_dir}/TMP_MULTIPATCH"
            echo "set ${patchset}" >> "${git_dir}/TMP_MULTIPATCH"
        fi
        prev="${patchset}"

        echo "pick ${entry}" >> "${git_dir}/TMP_MULTIPATCH"

    done <<< "${log}"
else
    while IFS= read -r entry; do
        echo "pick ${entry}" >> "${git_dir}/TMP_MULTIPATCH"
    done <<< "${log}"
fi


cat >> "${git_dir}/TMP_MULTIPATCH" <<End-of-message

# Commands:
# s, set <name> = introduce new patchset
# p, pick <commit> = use commit
#
# These lines can be re-ordered; they are executed from top to bottom.
# However, note that reordering may create conflicts when applying the created
# patches. Prefer creating sets in the original order or rebasing if a
# different order is desired.
#
End-of-message

if [[ "${opt_tags}" != y ]] || [[ "${opt_noconfirm}" != y ]]; then
    ${editor} "${git_dir}/TMP_MULTIPATCH"
fi


# parse instruction-file into dictionary
declare -A patchsets

set="a"
n_set=1
n_commit=0

while read -r p || [[ -n $p ]]; do

    # skip empty lines
    if [ -z "$p" ]; then
        continue
    fi

    # skip full-line comments
    if [[ "$p" == \#* ]]; then
        continue
    fi

    # split away right-hand-side comment
    IFS="#" read -r -a line <<< "${p}"

    # split line into tokens
    IFS=" " read -r -a line <<< "${line[0]}"

    # each line must have at least two tokens (command, argument)
    if [ ${#line[@]} -lt 2 ]; then
        echo "error: invalid line"
        exit 1
    fi

    # handle instruction
    command="${line[0]}"

    case "${command}" in
        s|set)
            set="${line[*]:1}"

            if [[ "$n_commit" -gt 0 ]]; then
                (( n_set+=1 ))
            fi

            n_commit=0
            ;;

        p|pick)
            key=$(printf '%04d-%s' "${n_set}" "${set}")
            commit=${line[1]}

            if [[ ${patchsets[${key}]+x} ]]
            then
                patchsets[${key}]="${patchsets[${key}]} ${commit}"
            else
                patchsets[${key}]="${commit}"

            fi

            (( n_commit+=1 ))
            ;;

        *)
            echo "invalid command: ${command}"
            exit 1
            ;;
    esac

done <"${git_dir}/TMP_MULTIPATCH"


# format patches
sets=("${!patchsets[@]}")
IFS=$'\n' sorted=($(sort <<<"${sets[*]}")); unset IFS

for set in "${sorted[@]}"; do
    patch=$(printf '%s.patch' "${set}")

    echo ""
    echo "${patch}:"

    rm -f "${patch}"

    for commit in ${patchsets[$set]}; do
        message=$(git log --format=%s -n 1 "${commit}")
        echo "  ${commit} ${message}"

        git format-patch ${GIT_OPTS} "${commit}" -1 --stdout >> "${patch}"
    done
done


# final cleanup
rm -f "${git_dir}/TMP_MULTIPATCH"
