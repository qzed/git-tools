#!/bin/bash
set -e
set -u


GIT_OPTS="${GIT_OPTS:-""}"

revs=""
git_dir="$(git rev-parse --show-toplevel)/.git"
editor=${EDITOR:-vim}

opt_tags=n
opt_noconfirm=n

function usage() {
    echo "git format-patchset [-t|--from-tags] [-a|--no-confirm] <revision-range>"
    echo ""
    echo "Description:"
    echo "  Format multi-patches, i.e. patch files with multiple complete commits"
    echo "  inside, from a given commit range. Commits can be assigned to/picked"
    echo "  for patch-sets interactively (similar to git rebase), or via a"
    echo ""
    echo "      Patchset: <name>"
    echo ""
    echo "  tag in the commit message."
    echo ""
    echo "Options:"
    echo "  -t --from-tags   Look for 'Patchset:' tags in commit messages and"
    echo "                   assign patch-set based on this. Commits without a"
    echo "                   'Patchset:' tag will be formatted in their own file."
    echo ""
    echo "  -a --no-confirm  Do not open editor for interactive assignment, i.e."
    echo "                   perform assignment automatically without user"
    echo "                   interaction. Only valid with -t/--from-tags."
}

while (( "${#}" )); do
    case ${1} in
        -h|--help)
            usage
            exit 0
            ;;
        -t|--from-tags)
            opt_tags=y
            ;;
        -a|--no-confirm)
            opt_noconfirm=y
            ;;
        *)
            revs="${1}"
            ;;
    esac

    shift
done

if [[ ! "${revs}" == *".."* ]]; then
    revs="${revs}.."
fi


# prepare instruction-file
echo "# Format patchsets in range ${revs}" > "${git_dir}/TMP_MULTIPATCH"

log=$(git log --reverse --oneline --no-merges "${revs}")

prev=""
if [[ "${opt_tags}" == y ]]; then

    while IFS= read -r entry; do
        read -r -a fields <<< "${entry}"

        commit="${fields[0]}"
        message=$(git log --format=%B "${commit}" -1)
        patchset=""

        while IFS= read -r line; do
            # split away right-hand-side comment
            IFS="#" read -r -a line <<< "${line}"

            if [[ "${#line[@]}" -eq 0 ]]
            then
                continue
            fi

            text="${line[0]}"

            # split line into tokens
            IFS=" " read -r -a tokens <<< "${text}"

            if [[ "${#tokens[@]}" -eq 0 ]]
            then
                continue
            fi

            # if tag, set patchset
            if [[ "${tokens[0]}" == "Patchset:" ]]; then
                patchset="${tokens[*]:1}"
            fi
        done <<< "${message}"

        if [ -z "${patchset}" ]; then
            patchset="${fields[*]:1}"
            patchset="${patchset//\:/}"
            patchset="${patchset//\(/}"
            patchset="${patchset//\)/}"
            patchset="${patchset//\//-}"
            patchset="${patchset// /-}"
            patchset=$(echo "${patchset}" | cut -c 1-52)
        fi

        if [[ "${prev}" != "${patchset}" ]]; then
            echo "" >> "${git_dir}/TMP_MULTIPATCH"
            echo "set ${patchset}" >> "${git_dir}/TMP_MULTIPATCH"
        fi
        prev="${patchset}"

        echo "pick ${entry}" >> "${git_dir}/TMP_MULTIPATCH"

    done <<< "${log}"
else
    while IFS= read -r entry; do
        echo "pick ${entry}" >> "${git_dir}/TMP_MULTIPATCH"
    done <<< "${log}"
fi


cat >> "${git_dir}/TMP_MULTIPATCH" <<End-of-message

# Commands:
# s, set <name> = introduce new patchset
# p, pick <commit> = use commit
#
# These lines can be re-ordered; they are executed from top to bottom.
# However, note that reordering may create conflicts when applying the created
# patches. Prefer creating sets in the original order or rebasing if a
# different order is desired.
#
End-of-message

if [[ "${opt_tags}" != y ]] || [[ "${opt_noconfirm}" != y ]]; then
    ${editor} "${git_dir}/TMP_MULTIPATCH"
fi


# parse instruction-file into dictionary
declare -A patchsets

set="a"
n_set=1
n_commit=0

while read -r p || [[ -n $p ]]; do

    # skip empty lines
    if [ -z "$p" ]; then
        continue
    fi

    # skip full-line comments
    if [[ "$p" == \#* ]]; then
        continue
    fi

    # split away right-hand-side comment
    IFS="#" read -r -a line <<< "${p}"

    # split line into tokens
    IFS=" " read -r -a line <<< "${line[0]}"

    # each line must have at least two tokens (command, argument)
    if [ ${#line[@]} -lt 2 ]; then
        echo "error: invalid line"
        exit 1
    fi

    # handle instruction
    command="${line[0]}"

    case "${command}" in
        s|set)
            set="${line[*]:1}"

            if [[ "$n_commit" -gt 0 ]]; then
                (( n_set+=1 ))
            fi

            n_commit=0
            ;;

        p|pick)
            key=$(printf '%04d-%s' "${n_set}" "${set}")
            commit=${line[1]}

            if [[ ${patchsets[${key}]+x} ]]
            then
                patchsets[${key}]="${patchsets[${key}]} ${commit}"
            else
                patchsets[${key}]="${commit}"

            fi

            (( n_commit+=1 ))
            ;;

        *)
            echo "invalid command: ${command}"
            exit 1
            ;;
    esac

done <"${git_dir}/TMP_MULTIPATCH"


# format patches
sets=("${!patchsets[@]}")
IFS=$'\n' sorted=($(sort <<<"${sets[*]}")); unset IFS

for set in "${sorted[@]}"; do
    patch=$(printf '%s.patch' "${set}")

    echo ""
    echo "${patch}:"

    rm -f "${patch}"

    for commit in ${patchsets[$set]}; do
        message=$(git log --format=%s -n 1 "${commit}")
        echo "  ${commit} ${message}"

        git format-patch ${GIT_OPTS} "${commit}" -1 --stdout >> "${patch}"
    done
done


# final cleanup
rm -f "${git_dir}/TMP_MULTIPATCH"
